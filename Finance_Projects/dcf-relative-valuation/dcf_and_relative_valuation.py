# -*- coding: utf-8 -*-
"""DCF and Relative Valuation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kHtowYJhJktlJmsGaWQzLJEYLdueviEZ
"""

# DCF Valuation

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import statsmodels.api as sm

# Set the ticker for SRF Ltd. (example ticker)
ticker_symbol = "SRF.NS"  # SRF Ltd. on NSE (Yahoo Finance code)

# Fetch data from Yahoo Finance
ticker = yf.Ticker(ticker_symbol)

# Balance Sheet and Income Statement -

# Get the balance sheet and income statement
balance_sheet = ticker.balance_sheet
income_statement = ticker.financials

# Transpose the data for better readability (Yahoo Finance data might be in columns for years)
balance_sheet = balance_sheet.T
income_statement = income_statement.T


# Preview data
print("Balance Sheet:\n", balance_sheet.head())
print("Income Statement:\n", income_statement.head())

# Plot Important Variables
def plot_financials(balance_sheet, income_statement):
    fig, axes = plt.subplots(2, 1, figsize=(10, 8))

    # Plot Balance Sheet variables
    balance_sheet[['Total Assets', 'Total Liabilities Net Minority Interest', 'Total Equity Gross Minority Interest']].plot(
        kind='bar', ax=axes[0], title="Balance Sheet Key Variables"
    )

    # Plot Income Statement variables
    income_statement[['Total Revenue', 'Gross Profit', 'Net Income']].plot(
        kind='bar', ax=axes[1], title="Income Statement Key Variables"
    )

    plt.tight_layout()
    plt.show()

plot_financials(balance_sheet, income_statement)

# Common sizing, horizontal analysis, and FCFF/FCFE projections
# Add rest of your financial analysis steps here as per the original script

# Save balance sheet and income statement to Excel for reference
excel_path = "SRF_Financial_Data_from_Yahoo_Finance.xlsx"
with pd.ExcelWriter(excel_path) as writer:
    balance_sheet.to_excel(writer, sheet_name='Balance Sheet')
    income_statement.to_excel(writer, sheet_name='Income Statement')

excel_path

# Common Sizing -

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import statsmodels.api as sm

# Set the ticker for SRF Ltd.
ticker_symbol = "SRF.NS"  # SRF Ltd. on NSE (Yahoo Finance code)

# Fetch data from Yahoo Finance
ticker = yf.Ticker(ticker_symbol)

# Fetch balance sheet and income statement
balance_sheet = ticker.balance_sheet.T
income_statement = ticker.financials.T

# Function to perform common sizing
def common_size_balance_sheet(df):
    return df.div(df['Total Assets'], axis=0) * 100

def common_size_income_statement(df):
    return df.div(df['Total Revenue'], axis=0) * 100

# Perform common sizing on balance sheet and income statement
balance_sheet_common = common_size_balance_sheet(balance_sheet)
income_statement_common = common_size_income_statement(income_statement)

# Save both original and common-sized data to Excel
excel_path = "SRF_Common_Sizing_Analysis.xlsx"
with pd.ExcelWriter(excel_path) as writer:
    balance_sheet.to_excel(writer, sheet_name="Balance Sheet Original")
    income_statement.to_excel(writer, sheet_name="Income Statement Original")
    balance_sheet_common.to_excel(writer, sheet_name="Balance Sheet Common Size")
    income_statement_common.to_excel(writer, sheet_name="Income Statement Common Size")

excel_path

# Common Sizing ratios -

# Function to perform common sizing
def common_size_balance_sheet(df):
    return df.div(df['Total Assets'], axis=0) * 100

def common_size_income_statement(df):
    return df.div(df['Total Revenue'], axis=0) * 100

# Common sizing for balance sheet and income statement
balance_sheet_common = common_size_balance_sheet(balance_sheet)
income_statement_common = common_size_income_statement(income_statement)

# Plotting common size ratios
def plot_common_size_ratios(balance_sheet_common, income_statement_common):
    # Plot Balance Sheet Ratios
    plt.figure(figsize=(12, 6))
    balance_sheet_common[['Total Liabilities Net Minority Interest', 'Total Equity Gross Minority Interest']].plot(
        kind='line', marker='o', title="Balance Sheet Common Size Ratios (%)", ylabel="Percentage of Total Assets")
    plt.grid(True)
    plt.legend(["Total Liabilities %", "Total Equity %"])
    plt.show()

    # Plot Income Statement Ratios
    plt.figure(figsize=(12, 6))
    income_statement_common[['Gross Profit', 'Operating Income', 'Net Income']].plot(
        kind='line', marker='o', title="Income Statement Common Size Ratios (%)", ylabel="Percentage of Total Revenue")
    plt.grid(True)
    plt.legend(["Gross Profit %", "Operating Income %", "Net Income %"])
    plt.show()

# Call the function to plot
plot_common_size_ratios(balance_sheet_common, income_statement_common)

# Horizontal Analysis -

# Perform horizontal analysis
income_statement_horizontal = income_statement.pct_change() * 100  # Percentage change

# Plotting horizontal analysis
def plot_horizontal_analysis(income_statement_horizontal):
    # Selecting key variables to plot
    plt.figure(figsize=(12, 6))
    income_statement_horizontal[['Total Revenue', 'Gross Profit', 'Operating Income', 'Net Income']].plot(
        kind='line', marker='o', title="Income Statement Horizontal Analysis (%)", ylabel="Percentage Change")
    plt.grid(True)
    plt.legend(["Total Revenue % Change", "Gross Profit % Change", "Operating Income % Change", "Net Income % Change"])
    plt.show()

# Call the function to plot horizontal analysis
plot_horizontal_analysis(income_statement_horizontal)

# Prospective Analysis -

# Step 1: Calculate average ratios for last three years

# Calculate Gross Margin, Operating Margin, and Net Margin for the last 3 years
income_statement['Gross Margin'] = income_statement['Gross Profit'] / income_statement['Total Revenue']
income_statement['Operating Margin'] = income_statement['Operating Income'] / income_statement['Total Revenue']
income_statement['Net Margin'] = income_statement['Net Income'] / income_statement['Total Revenue']

# Calculate the average ratios for last 3 years
average_gross_margin = income_statement['Gross Margin'].iloc[:3].mean()
average_operating_margin = income_statement['Operating Margin'].iloc[:3].mean()
average_net_margin = income_statement['Net Margin'].iloc[:3].mean()

# Assumed revenue growth rate based on past three years (for demonstration purposes)
revenue_growth_rate = income_statement['Total Revenue'].pct_change().iloc[:3].mean()

# Step 2: Project income statement for the next 5 years
years = [2025, 2026, 2027, 2028, 2029]
projected_revenue = [income_statement['Total Revenue'].iloc[0] * ((1 + revenue_growth_rate) ** i) for i in range(1, 6)]
projected_gross_profit = [revenue * average_gross_margin for revenue in projected_revenue]
projected_operating_income = [revenue * average_operating_margin for revenue in projected_revenue]
projected_net_income = [revenue * average_net_margin for revenue in projected_revenue]

# Create a DataFrame for projected values
projected_income_statement = pd.DataFrame({
    'Year': years,
    'Projected Revenue': projected_revenue,
    'Projected Gross Profit': projected_gross_profit,
    'Projected Operating Income': projected_operating_income,
    'Projected Net Income': projected_net_income
})

# Step 3: Plot the projected figures
def plot_prospective_analysis(projected_income_statement):
    projected_income_statement.set_index('Year')[['Projected Revenue', 'Projected Gross Profit',
                                                  'Projected Operating Income', 'Projected Net Income']].plot(
        kind='line', marker='o', title="Projected Income Statement (Next 5 Years)", figsize=(12, 6)
    )
    plt.ylabel("Amount")
    plt.grid(True)
    plt.show()

# Call the function to plot the projected income statement
plot_prospective_analysis(projected_income_statement)

# Show projected income statement for reference
projected_income_statement

# FCFF and FCFE -

# Calculate Effective Tax Rate using historical data
effective_tax_rate = 1 - (income_statement['Net Income'] / income_statement['Pretax Income'])
average_tax_rate = effective_tax_rate.mean()

# Calculate historical averages for Depreciation, CapEx, ΔWC, Interest Expense, and Net Borrowing
average_depreciation = income_statement['Depreciation And Amortization In Income Statement'].iloc[:3].mean()
average_capex = balance_sheet['Gross PPE'].pct_change().iloc[:3].mean()
average_delta_wc = balance_sheet['Working Capital'].pct_change().iloc[:3].mean()

average_interest_expense = income_statement['Interest Expense'].iloc[:3].mean()
average_net_borrowing = balance_sheet['Total Debt'].pct_change().iloc[:3].mean()

# Revenue growth rate from previous analysis
revenue_growth_rate = income_statement['Total Revenue'].pct_change().iloc[:3].mean()
print("\nGrowth rate:", revenue_growth_rate)

# Project future revenue, operating income, FCFF, and FCFE for the next 5 years
years = [2025, 2026, 2027, 2028, 2029]
projected_revenue = [income_statement['Total Revenue'].iloc[0] * ((1 + revenue_growth_rate) ** i) for i in range(1, 6)]
projected_operating_income = [revenue * (income_statement['Operating Income'] / income_statement['Total Revenue']).iloc[:3].mean() for revenue in projected_revenue]

projected_fcff = []
projected_fcfe = []

for i, op_income in enumerate(projected_operating_income):
    # Calculate FCFF
    fcff = (op_income * (1 - average_tax_rate)) + average_depreciation - average_capex - average_delta_wc
    projected_fcff.append(fcff)

    # Calculate FCFE
    fcfe = fcff - (average_interest_expense * (1 - average_tax_rate)) + average_net_borrowing
    projected_fcfe.append(fcfe)

# Create DataFrame for projected values
projected_cash_flows = pd.DataFrame({
    'Year': years,
    'Projected Revenue': projected_revenue,
    'Projected Operating Income': projected_operating_income,
    'Projected FCFF': projected_fcff,
    'Projected FCFE': projected_fcfe
})

# Plotting FCFF and FCFE
def plot_fcff_fcfe(projected_cash_flows):
    projected_cash_flows.set_index('Year')[['Projected FCFF', 'Projected FCFE']].plot(
        kind='line', marker='o', title="Projected FCFF and FCFE (Next 5 Years)", ylabel="Amount", figsize=(12, 6)
    )
    plt.grid(True)
    plt.legend(["Projected FCFF", "Projected FCFE"])
    plt.show()

# Call the function to plot FCFF and FCFE
plot_fcff_fcfe(projected_cash_flows)

# Show the projected DataFrame for reference
projected_cash_flows[['Year', 'Projected FCFF', 'Projected FCFE']]

#
import numpy as np
import pandas as pd
import yfinance as yf
from scipy import stats

# Define the company and the market index
company_ticker = "SRF.NS"  # Adjust this if SRF has a different ticker on your chosen source
market_ticker = "^NSEI"    # Nifty 50 Index for India

# Step 1: Calculate Beta Equity using Regression
def calculate_beta(company_ticker, market_ticker, start_date, end_date):
    # Download historical data
    company_data = yf.download(company_ticker, start=start_date, end=end_date)['Adj Close']
    market_data = yf.download(market_ticker, start=start_date, end=end_date)['Adj Close']

    # Calculate daily returns
    company_returns = company_data.pct_change().dropna()
    market_returns = market_data.pct_change().dropna()

    # Perform linear regression
    slope, intercept, r_value, p_value, std_err = stats.mstats.linregress(market_returns.to_numpy(), company_returns.to_numpy())
    beta=slope
    return beta

# Step 2: Calculate Cost of Equity (using CAPM)
def calculate_cost_of_equity(beta, risk_free_rate, market_return):
    cost_of_equity = risk_free_rate + beta * (market_return - risk_free_rate)
    return cost_of_equity

# Step 3: Estimate Cost of Debt (Synthetic Rating or Alternative Methods)
def estimate_cost_of_debt(credit_rating, risk_free_rate, default_spread):
    # Cost of debt = Risk-free rate + default spread for the credit rating
    cost_of_debt = risk_free_rate + default_spread
    return cost_of_debt

# Step 4: Calculate Market Value of Equity
def calculate_market_value_of_equity(company_ticker):
    company = yf.Ticker(company_ticker)
    shares_outstanding = company.info['sharesOutstanding']
    current_price = company.info['currentPrice']
    market_value_of_equity = shares_outstanding * current_price
    return market_value_of_equity

# Step 5: Calculate Market Value of Debt
def calculate_market_value_of_debt(total_debt, book_value):
    # Approximate market value of debt as close to book value if information is not available
    market_value_of_debt = total_debt
    return market_value_of_debt

# Step 6: Calculate Weighted Average Cost of Capital (WACC)
def calculate_wacc(market_value_of_equity, market_value_of_debt, cost_of_equity, cost_of_debt, tax_rate):
    total_value = market_value_of_equity + market_value_of_debt
    equity_weight = market_value_of_equity / total_value
    debt_weight = market_value_of_debt / total_value
    wacc = (equity_weight * cost_of_equity) + (debt_weight * cost_of_debt * (1 - tax_rate))
    return wacc

# Parameters for calculation
risk_free_rate = 0.07
market_return = 0.12
start_date = '2023-01-01'      # Start date for historical data
end_date = '2024-01-01'        # End date for historical data
default_spread = 0.007

# Calculation process
beta = calculate_beta(company_ticker, market_ticker, start_date, end_date)
cost_of_equity = calculate_cost_of_equity(beta, risk_free_rate, market_return)
market_value_of_equity = calculate_market_value_of_equity(company_ticker)
market_value_of_debt = calculate_market_value_of_debt(total_debt=500000000, book_value=450000000)
cost_of_debt = estimate_cost_of_debt('AA', risk_free_rate, default_spread)

tax_rate = 0.25

# Calculate WACC
wacc = calculate_wacc(market_value_of_equity, market_value_of_debt, cost_of_equity, estimate_cost_of_debt('AA', risk_free_rate, default_spread), tax_rate)

# Output results
print(f"Beta: {beta}")
print(f"Cost of Debt: {cost_of_debt}")
print(f"Cost of Equity: {cost_of_equity}")
print(f"Market Value of Equity: {market_value_of_equity}")
print(f"Market Value of Debt: {market_value_of_debt}")
print(f"WACC: {wacc}")

# Given data - Projected FCFF values for the next 5 years in crores
fcff_values = [2.439771e+10, 2.415753e+10, 2.392046e+10, 2.368647e+10, 2.345552e+10]  # FCFF values for years 2025-2029

# Assumptions for the DCF calculation
terminal_growth_rate = 0.0889  # Terminal growth rate (8.89%)
discount_rate = 0.118  # Discount rate (11.8%)
projection_years = len(fcff_values)  # Number of explicit forecast years

# Calculate Terminal Value at the end of projection period (Year 2029)
terminal_value = fcff_values[-1] * (1 + terminal_growth_rate) / (discount_rate - terminal_growth_rate)

# Discount each FCFF and the Terminal Value to present value
present_value_fcffs = [fcff / (1 + discount_rate) ** i for i, fcff in enumerate(fcff_values, start=1)]
present_value_terminal = terminal_value / (1 + discount_rate) ** projection_years

# Calculate the intrinsic value of the firm (sum of discounted FCFFs and Terminal Value)
intrinsic_value = sum(present_value_fcffs) + present_value_terminal

# Output the intrinsic value
print(f"The intrinsic value of SRF Ltd. using DCF valuation is approximately: ₹{intrinsic_value:.2f} ")

# Relative Valuation

import yfinance as yf
import pandas as pd
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format="%(levelname)s: %(message)s")

# Define tickers for SRF Limited and comparable companies
ticker_srf = "SRF.NS"
comparables = ["FLUOROCHEM.NS", "PIDILITIND.NS", "AARTIIND.NS"]

# Function to retrieve balance sheet and income statement for SRF Limited
def fetch_srf_financials(ticker_symbol):
    ticker = yf.Ticker(ticker_symbol)
    try:
        balance_sheet = ticker.balance_sheet.T
        income_statement = ticker.financials.T
        if income_statement.empty:
            raise ValueError("Income statement is empty, attempting web scraping.")
    except Exception as e:
        logging.warning(f"yfinance could not retrieve data: {e}")
        url = f"https://finance.yahoo.com/quote/{ticker_symbol}/financials?p={ticker_symbol}"
        try:
            tables = pd.read_html(url)
            income_statement = tables[0]  # First table should be the income statement
            balance_sheet = tables[1]     # Adjust index as necessary for balance sheet
            logging.info("Data successfully retrieved via web scraping.")
        except Exception as e:
            logging.error(f"Failed to retrieve data via web scraping: {e}")
            return None, None
    return balance_sheet, income_statement

# Retrieve SRF's balance sheet and income statement
balance_sheet, income_statement = fetch_srf_financials(ticker_srf)

# Extract SRF's Net Income for P/E calculation
net_income_srf = None
if income_statement is not None:
    try:
        # Adjust column name as necessary after inspecting the data
        logging.info(f"Income Statement Columns: {income_statement.columns}")
        net_income_srf = income_statement.loc[income_statement.index[0], "Net Income"]
        logging.info(f"SRF's Net Income: {net_income_srf}")
    except KeyError as e:
        logging.warning(f"Net Income column not found: {e}")
else:
    logging.warning("Income statement is None.")

# Function to fetch comparable companies' financials
def fetch_comparable_data(ticker_symbol):
    ticker = yf.Ticker(ticker_symbol)
    try:
        info = ticker.info
        market_cap = info.get("marketCap", 0)
        ebitda = info.get("ebitda", 0)
        pe_ratio = info.get("trailingPE", 0)
        debt = info.get("totalDebt", 0)
        cash = info.get("totalCash", 0)
        ev = market_cap + debt - cash  # Calculate Enterprise Value (EV)
        ev_to_ebitda = ev / ebitda if ebitda else 0
        logging.info(f"Ticker: {ticker_symbol} | EV/EBITDA: {ev_to_ebitda:.2f}")
        return {
            "ticker": ticker_symbol,
            "market_cap": market_cap,
            "pe_ratio": pe_ratio,
            "ev_to_ebitda": ev_to_ebitda,
        }
    except Exception as e:
        logging.error(f"Error fetching data for {ticker_symbol}: {e}")
        return {"ticker": ticker_symbol, "market_cap": 0, "pe_ratio": 0, "ev_to_ebitda": 0}

# Fetch data for comparable companies and calculate industry multiples
data = [fetch_comparable_data(ticker) for ticker in comparables]
pe_ratios = [d["pe_ratio"] for d in data if d["pe_ratio"] > 0]
ev_to_ebitda_ratios = [d["ev_to_ebitda"] for d in data if d["ev_to_ebitda"] > 0]

# Calculate industry average multiples
industry_pe = sum(pe_ratios) / len(pe_ratios) if pe_ratios else 0
industry_ev_to_ebitda = sum(ev_to_ebitda_ratios) / len(ev_to_ebitda_ratios) if ev_to_ebitda_ratios else 0

# Relative Valuation of SRF Limited
# Calculate SRF's valuation based on industry multiples
srf_value_pe = industry_pe * net_income_srf if net_income_srf else 0

# Retrieve SRF's EBITDA for EV/EBITDA calculation
try:
    ebitda_srf = yf.Ticker(ticker_srf).info.get("ebitda", 0)
    srf_value_ev_to_ebitda = industry_ev_to_ebitda * ebitda_srf if ebitda_srf else 0
except Exception as e:
    logging.error(f"Error retrieving SRF's EBITDA: {e}")
    ebitda_srf = 0
    srf_value_ev_to_ebitda = 0

# Display calculated valuations
print("\nIndustry Multiples:")
print(f"- P/E Ratio: {industry_pe:.2f}")
print(f"- EV/EBITDA Ratio: {industry_ev_to_ebitda:.2f}")

print("\nSRF Valuation:")
print(f"- Based on P/E: ₹{srf_value_pe:,.2f}")
print(f"- Based on EV/EBITDA: ₹{srf_value_ev_to_ebitda:,.2f}")