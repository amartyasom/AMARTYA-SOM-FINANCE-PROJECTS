# -*- coding: utf-8 -*-
"""WACC Estimation data- Wipro.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nrUYo5U8YesMAsGA104SXTFa_9cOppXj
"""

import numpy as np
import scipy.optimize as sc
import statsmodels.api as sm
import datetime as dt
import pandas as pd
import matplotlib.pyplot as plt
from pandas_datareader import data as pdr
import yfinance as yf
import plotly.express as px
import seaborn as sns
!pip install yfinance
!pip install plotly
!pip install seaborn
import scipy.stats as stats
#yf.pdr_override()

#Download stock prices for the security monthly data last 5 years
wipro_df = yf.download('WIPRO.NS',
                      start='2020-01-11',
                      end='2024-01-10',
                      progress=False,interval ='1mo'
)
wipro_df.head()

#Download Market index closing prices
nifty_df = yf.download('^BSESN',start='2020-01-11',
                      end='2024-01-10',
                      progress=False,interval ='1mo',
)
nifty_df.head()
# This is a 5 year historical data from 2020 to 2024.

#Calculate Log returns
nifty_df['Return_NIFTY'] = np.log(nifty_df['Adj Close']/nifty_df['Adj Close'].shift(1))
print(nifty_df['Return_NIFTY'])

nifty_df['Return_NIFTY'].plot(figsize=(8,5))
plt.show()

nifty_df['Adj Close'].plot(figsize=(8,5))
plt.show()

nifty_df1 = nifty_df.dropna(axis=0)
nifty_df1.head()

#Caclulate log returns
wipro_df['Return_WIPRO'] = np.log(wipro_df['Adj Close']/wipro_df['Adj Close'].shift(1))
print(wipro_df['Return_WIPRO'])

wipro_df1 = wipro_df.dropna(axis=0)
wipro_df1.head()

wipro_df['Return_WIPRO'].plot(figsize=(8,5))
plt.show()

wipro_df['Adj Close'].plot(figsize=(8,5))
plt.show()

wipro_df1_returns = wipro_df1['Return_WIPRO']
wipro_df1_returns.head()

nifty_df1_returns = nifty_df1['Return_NIFTY']
nifty_df1_returns.head()

returns = pd.merge(nifty_df1_returns,wipro_df1_returns,how='inner',on='Date')
returns.head()
returns.describe()

sns.pairplot(returns)
plt.show()

sns.heatmap(returns.corr(), annot = True, cmap="YlGnBu")
plt.show()

x = returns['Return_NIFTY']
y = returns['Return_WIPRO']
x_sm = sm.add_constant(x)

"""Assumptions of OLS regression, a linear relationship between the dependent and independent variables - The linear regression model is linear in parameters The independent variables are not highly correlated with each other - no multicollinearity The variance of the residuals is constant - no heteroskedasticity Random sampling of observation and no autocorrelation Assumption of Normality of Errors

Ri = αi + βi(RM) + εi.........Market model

• Ri = Return of security i

• αi = The return from the asset that is not related to the market’s return. This is “alpha” return from the security

• βi = Beta or the return from the security explained by the market index’s return

• RM = The market index’s return

• εi = Error term for past returns not explained by the regression equation
"""

#Regression - Market model
model = sm.OLS(y,x_sm)

"""OLS estimation or Ordinary Least square Minimizes the sum of squared errors."""

results = model.fit()

#Regression result
results.summary()

#Regression - Security Characteristic line
returns.info()
sns.regplot(x = 'Return_NIFTY', y = 'Return_WIPRO', data = returns)

print('resid', results.resid)

#Histogram of residuals
sns.distplot(results.resid)
results.resid.describe()

#Checking for Homoskedasticity of errors (Assumption requirement of linear regression)
#perform White's test
from statsmodels.stats.diagnostic import het_white
white_test = het_white(results.resid,  results.model.exog)

#define labels to use for output of White's test
labels = ['Test Statistic', 'Test Statistic p-value', 'F-Statistic', 'F-Test p-value']

#print results of White's test
print(dict(zip(labels, white_test)))

#Testing for Normality of errors (Assumption requirement of linear regression)
import scipy.stats as stats # Import the stats module from scipy
import statsmodels.api as sm

sm.qqplot(results.resid, line='45', fit=True, dist=stats.norm)

stats.normaltest(results.resid)

"""We can see that since we are plotting the data with the theoretical quantiles of a normal distribution, we are getting almost a straight line, though some points are not exactly on the line. The D’Agostino’s K-squared test result suggests that the null hypothesis that the distribution is normal cannot be rejected at 1% significance level.

Calculation of EBIT/Interest Expense (Interest Coverage Ratio)
"""

import yfinance as yf

# Company ticker
company_ticker = "WIPRO.NS"

# Fetch financial data
company = yf.Ticker(company_ticker)
income_statement = company.financials

# Inspect income_statement to find correct labels for EBIT and Interest Expense
# print(income_statement)  # Uncomment to inspect and find correct labels

# Assuming 'Operating Income' is the label for EBIT
ebit_label = 'Operating Income'
try:
    ebit = income_statement.loc[ebit_label].iloc[0] # Get the latest EBIT value
except KeyError:
    print(f"Error: Label '{ebit_label}' not found in income_statement. Please check the DataFrame.")
    ebit = None # Set to None if label not found

# Assuming 'Interest Expense' is the label for Interest Expense
interest_expense_label = 'Interest Expense'
try:
    interest_expense = income_statement.loc[interest_expense_label].abs().iloc[0] # Get the latest Interest Expense value
except KeyError:
    print(f"Error: Label '{interest_expense_label}' not found in income_statement. Please check the DataFrame.")
    interest_expense = None # Set to None if label not found

# Calculate Interest Coverage Ratio if both values are available
if ebit is not None and interest_expense is not None and interest_expense != 0:
    interest_coverage_ratio = ebit / interest_expense
    print(f"Interest Coverage Ratio for {company_ticker}: {interest_coverage_ratio}")
else:
    print("Error: Cannot calculate Interest Coverage Ratio. Missing or invalid EBIT or Interest Expense data.")

